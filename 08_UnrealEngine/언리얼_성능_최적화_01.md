# [심층 분석] 감으로 때려잡는 최적화는 그만! 언리얼 엔진 성능 최적화와 프로파일링 A to Z

오늘의 공부는 에픽게임즈 코리아의 **'언리얼 서밋 2020: 사례로 배우는 성능 최적화와 프로파일링'** 내용을 바탕으로, 데이터에 기반해 범인을 정확히 찾아내고 해결하는 **프로파일링의 정석**을 정리해 보겠습니다.
---

## 🔍 1. 서론: 프로파일링은 '과학 수사'다

유튜브에서 강연자분께서는 프로파일링을 **범죄 수사와 같다.**고 비유했습니다. 이 비유가 최적화의 핵심을 관통합니다.

> **"프로파일링은 범죄 수사와 같다."**

* **현행범 체포 (쉬움):** 방금 코드를 짰는데 갑자기 게임이 느려졌다? 이건 바로 잡을 수 있다.
* **미제 사건 수사 (어려움):** 개발 초기부터 조금씩 쌓여온 비효율적인 코드와 에셋들이 뭉쳐서, 프로젝트 후반부에 원인을 알 수 없는 렉을 유발한다면? 증거가 다 사라져서 원인을 찾기 정말 힘들다.

### 💡 개발자가 가져야 할 태도
1.  **출시 전 몰아치기는 금물:** 최적화는 출시 직전에 하는 '마무리 작업'이 아니라 프로젝트 시작부터 끝까지 함께해야 하는 **'상시 업무'** 이다.
2.  **성능 예산(Budget) 설정:** 목표 프레임에 따라 우리가 쓸 수 있는 시간은 정해져 있습니다.
    * **60fps 목표:** 1프레임당 **16.6ms**
    * **30fps 목표:** 1프레임당 **33.3ms**
    * 이 시간을 캐릭터, 배경, UI, 로직이 알뜰하게 나눠 써야하고 예산을 초과하면? 기능 하나를 빼거나 그래픽 퀄리티를 타협해야 한다.

---

## 💻 2. 하드웨어 메커니즘의 이해: 도대체 왜 느려지는가? (심화)

무작정 `stat unit`을 치기 전에, 컴퓨터가 어떻게 일하는지 알면 최적화의 근본 원리가 보인다.

### ① '메모리 장벽 (Memory Wall)'의 이해
> **"CPU는 페라리인데, 도로는 꽉 막힌 비포장도로다."** 

지난 수십 년간 **CPU의 연산 속도**는 비약적으로 빨라졌지만, **메모리(RAM)의 접근 속도**는 그만큼 빨라지지 못했습니다. 이 속도 차이가 엄청난 병목을 만듭니다.

* **비유:**
    * **CPU (요리사):** 1초에 양파를 100개 썰 수 있는 초고수.
    * **RAM (냉장고):** 요리사가 재료를 가지러 가는 곳. 왕복 10분 거리.
    * **결과:** 요리사는 칼질 1초 하고, 재료 가지러 10분 동안 놓습니다. (CPU 유휴 상태)

이 현상을 해결하기 위해 **캐시(Cache)**라는 '도마 옆 미니 아이스박스'를 두었습니다.

### ② 캐시 히트(Cache Hit)와 데이터 지역성(Data Locality)
최적화의 핵심은 **"한번 냉장고(RAM)에 갔을 때, 필요한 걸 몽땅 가져와서 아이스박스(Cache)에 넣어두는 것"**입니다.

* **캐시 라인 (Cache Line):** CPU는 데이터를 1바이트씩 가져오지 않습니다. 보통 **64바이트 덩어리(Cache Line)**로 한꺼번에 퍼옵니다.
* **TArray vs TLinkedList:**
    * **TArray (연속된 메모리):** 1번 데이터를 요청해서 가져오면, 옆에 있는 2, 3, 4번 데이터도 같이 딸려옵니다. (캐시 히트! 👍)
    * **LinkedList (흩어진 메모리):** 1번을 가져왔는데, 2번은 저 멀리 다른 주소에 있습니다. 또 RAM에 갔다 와야 합니다. (캐시 미스! 👎)

> **💡 핵심:** 가능하면 **`TArray`**와 같은 연속된 메모리 컨테이너를 사용하고, 포인터(->)를 따라가는 구조(Indirection)를 줄이세요. 이것이 바로 **데이터 지향 설계(Data-Oriented Design)**의 기초입니다.

### ③ 발열과 스로틀링 (Throttling): 모바일의 생존 본능
모바일 기기는 PC처럼 **쿨링팬**이 없습니다. 오로지 기기 표면으로 열을 식혀야 합니다.

1.  **발열의 원리:** 성능을 높이려면 전압을 높여야 합니다. 하지만 발열량은 **전압의 제곱($V^2$)**에 비례해 폭발적으로 늘어납니다.
2.  **스로틀링(Throttling):** CPU/GPU 온도가 위험 수준(보통 40~50도)에 도달하면, 기기는 살기 위해 강제로 **성능(클럭)을 절반 이하로 깎아버립니다.**
3.  **결과:** 처음 5분은 60프레임이 나오다가, 폰이 뜨거워지면서 갑자기 20프레임으로 곤두박질칩니다.

> **⚠️ 주의:** 짧은 테스트는 의미가 없습니다. 최소 15분 이상 구동하여 **'열적 평형 상태(Thermal Equilibrium)'**에 도달했을 때의 프레임을 측정해야 합니다.

---

## 🛠️ 3. [Level 1] 에디터 내장 도구로 '눈'으로 범인 찾기

복잡한 외부 툴을 쓰기 전, 에디터 뷰포트에서 직관적으로 문제를 발견할 수 있습니다.

### 1) 뷰 모드 (View Mode) 최적화
뷰포트 상단 `Lit` 버튼을 눌러 다양한 모드로 전환해 보세요.

* **Light Complexity (라이트 복잡도):**
    * **화면:** 검정~초록(양호) / **주황~빨강(위험)** / 흰색(심각)
    * **원인:** 무버블(Movable) 라이트가 한 픽셀에 너무 많이 겹쳐 있습니다. 동적 라이트는 비용이 매우 비쌉니다.
    * **해결:** 불필요한 라이트는 `Static`이나 `Stationary`로 변경하여 라이트맵을 굽습니다.

* **Shader Complexity (셰이더 복잡도 & Quad Overdraw):**
    * **화면:** **흰색이나 분홍색**으로 빛나는 영역 확인
    * **원인:** 투명한(Translucent) 파티클이나 이펙트가 너무 많이 겹쳐서, 뒤쪽 픽셀까지 계속 다시 그리고(Overdraw) 있는 상황입니다.
    * **해결:** 파티클 생성 수를 줄이거나, 머티리얼을 단순화합니다.

> **✅ 실습 가이드 (Action Item)**
> 1. 본인이 작업 중인 레벨을 엽니다.
> 2. 뷰포트 상단 `Lit` -> `Optimization Viewmodes` -> `Light Complexity`를 선택하세요.
> 3. 아래에 캡처를 넣어봅시다. 빨간색 영역이 있다면 라이트를 줄여야 합니다.
>
> ![실습 인증: 나의 레벨 Light Complexity]![복잡도](image.png))
>
> 4. 이번엔 `Shader Complexity`를 선택하여 가장 부하가 심한(하얀색) 이펙트를 찾아보세요.
>
> ![실습 인증: 나의 레벨 Shader Complexity](![복잡도](image-1.png))

### 2) Statistics (통계) 창 활용
`Window` > `Statistics` 메뉴를 엽니다. 이곳은 내 레벨에 있는 모든 에셋의 '건강검진표'입니다.

* **Texture Stats:** 리스트를 크기순으로 정렬해 보세요. 아주 작은 돌맹이나 나사못인데 **4K(4096) 텍스처**를 쓰고 있진 않나요?
* **해결:** 텍스처 설정의 `Max Texture Size`를 512 등으로 제한하세요. 원본 소스는 유지하면서 게임 내 메모리 사용량만 즉시 줄일 수 있습니다.
![통계](image-2.png)
---

## 📉 4. [Level 2] Stat 커맨드: 수치로 용의자 좁히기 (가장 중요!)

이제 콘솔 창(`~` 키)을 열고 구체적인 수치를 확인해 봅시다.

### 1) `stat unit` : 병목 구간 판별기
가장 먼저 입력해야 할 명령어입니다. 프레임 타임을 4가지 영역으로 쪼개서 보여줍니다. 이 중 **가장 높은 숫자가 바로 병목(Bottle Neck)**입니다.

| 항목 | 의미 | 주요 원인 및 담당자 |
| :--- | :--- | :--- |
| **Frame** | 전체 프레임 시간 | 가장 느린 스레드의 시간을 따라갑니다. |
| **Game** | 게임 로직 처리 (CPU) | 블루프린트, AI, 물리 연산, 틱(Tick) 남용. **(프로그래머 담당)** |
| **Draw** | 렌더링 명령 생성 (CPU) | 드로우 콜(Draw Call) 과다. 오브젝트가 너무 많음. **(배경/레벨 디자이너 담당)** |
| **GPU** | 그래픽 처리 (GPU) | 셰이더 복잡도, 고해상도, 포스트 프로세싱. **(TA/이펙터 담당)** |

> **✅ 실습 가이드 (Action Item)**
> 1. `~` 키를 눌러 콘솔 창을 엽니다.
> 2. `stat unit`을 입력하고 엔터를 칩니다.
> 3. 내 프로젝트에서 **가장 숫자가 높은 항목(병목)**이 무엇인지 확인하고 캡처하세요.
>
> ![실습 인증: stat unit 결과](![alt text](image-3.png))

### 2) `stat game` : CPU가 바쁜 이유
`stat unit`에서 **Game** 수치가 높다면 입력합니다.
![alt text](image-4.png)
* `World Tick`, `Physics`, `Blueprint` 등 세부 항목이 나옵니다.
* 만약 `CharMovement`가 높다면? 캐릭터 이동/충돌 처리가 범인입니다.

### 3) 소거법 (Elimination Strategy) 활용
수치만으로 모르겠다면? 하나씩 꺼보면서 범인을 색출합니다.
* `show staticmeshes`: 배경을 숨겼더니 빨라진다? → **폴리곤/드로우 콜 문제**
* `show particles`: 이펙트를 껐더니 빨라진다? → **파티클 문제**
* `pause` 후 `slomo 0.1`: 게임을 일시 정지하거나 아주 느리게 재생하면서, **특정 스킬을 쓰는 그 찰나의 순간**에 프레임이 튀는지 확인합니다.

> **💡 꿀팁 (치트키 제작):**
> 모바일 기기에서 매번 타자를 치기 힘들죠? 블루프린트로 **'화면을 세 손가락 터치하면 stat unit 토글'** 같은 기능을 미리 만들어 두세요. 실무에서 정말 유용하게 쓰입니다.

---

## 🔬 5. [Level 3] 정밀 분석: Unreal Insights (실전 가이드)

`stat` 명령어는 "범인이 이 방에 있다" 정도만 알려줍니다. "범인은 바로 이 함수다!"라고 지목하려면 언리얼 엔진의 최신 프로파일링 툴인 **Unreal Insights**를 써야 합니다.

### 🚀 Unreal Insights 실행 및 연결 방법 (따라해보세요!)

**1단계: Unreal Insights 실행**
언리얼 엔진이 설치된 폴더로 가서 프로그램을 실행합니다. (에디터 내장이 아니라 별도 프로그램입니다.)
*   **경로:** `.../UE_5.x/Engine/Binaries/Win64/UnrealInsights.exe`
*   실행하면 아까운 세션 브라우저 창이 뜹니다.

**2단계: 게임을 Trace 모드로 실행**
에디터에서 바로 실행하지 않고, **CMD(명령 프롬프트)**나 **바로가기**를 통해 옵션을 주고 실행해야 합니다.
1.  프로젝트의 `.uproject` 파일이 잇는 곳에서 우클릭 -> `Launch Game`을 하거나,
2.  에디터 상단 `Play` 버튼 옆 점 3개 -> `Net Mode: Standalone` -> `Advanced Settings` -> `New Editor Window Arguments`에 아래 명령어를 입력합니다.
    *   `-trace=cpu,frame,bookmark`

**3단계: 분석하기**
1.  게임이 실행되면 Unreal Insights 창에 실시간으로 세션이 잡힙니다. 더블 클릭하여 엽니다.
2.  **Timing Insights** 탭을 봅니다.
3.  프레임이 튀는 구간(빨간색 막대)을 드래그하여 확대합니다.
4.  `Game Thread` 라인을 자세히 보면, 어떤 함수가 시간을 많이 잡아먹었는지 **범인**이 보입니다.

> **✅ 실습 가이드 (Action Item)**
> 1. `UnrealInsights.exe`를 실행합니다.
> 2. 에디터 플레이(PIE) 혹은 Standalone으로 게임을 실행합니다. (최신 엔진은 PIE도 자동 연결됩니다)
> 3. Insights 창에 내 세션이 뜨는지 확인하고 스크린샷을 찍어주세요.
>
> ![실습 인증: Unreal Insights 실행 모습](![alt text](image-5.png))

### 1) Timing Insights (타임라인 분석)
전체 게임 플레이를 타임라인으로 쫙 펼쳐 보여줍니다.
* 그래프가 평평하다가 갑자기 툭 튀어나온(Spike) 프레임을 클릭합니다.
* 해당 프레임의 1/60초 시간을 나노초 단위로 분해해서 보여줍니다.
* **[실제 사례]** `Game Thread`가 30ms를 썼는데, 자세히 보니 `CharacterMovementComponent` 혼자 20ms를 먹고 있었다! -> 물리 연산을 최적화해야 한다는 결론 도출.

### 2) Asset Loading Insights (로딩 분석)
"게임 켜질 때 왜 이렇게 오래 걸려?"
* 로딩 바(Bar)를 분석하여 어떤 텍스처나 모델을 불러오느라 디스크 I/O가 발생했는지 보여줍니다.
* 동기 로딩(Synchronous Loading) 때문에 게임이 멈추는 구간을 찾아낼 수 있습니다.

### 3) 모바일 원격 프로파일링 팁
PC와 모바일 폰을 USB로 연결하고, PC의 Unreal Insights 툴로 폰의 성능을 실시간으로 감시할 수 있습니다.
* **방법:** `UE4CommandLine.txt`라는 텍스트 파일에 프로파일링 명령어(`-trace=cpu,frame,bookmark` 등)를 적어서 안드로이드 폰 내부 저장소(`UE4Game/프로젝트명/`)에 넣어주면 됩니다.

---

## 📝 6. 결론: 최적화는 '습관'이자 '데이터'다

이 강연을 통해 얻을 수 있는 결론은 명확합니다.

1.  **감에 의존하지 마세요:** "이거 무거울 것 같은데?"는 틀릴 확률이 높습니다. `stat unit`과 `Unreal Insights`가 보여주는 **숫자**를 믿으세요.
2.  **환경을 통제하세요:** 에디터(PIE)는 무겁습니다. 반드시 **Standalone(독립형) 모드**나 실제 **타겟 디바이스**에서 측정하세요.
3.  **병목 지점을 정확히 타격하세요:** CPU가 병목인데 그래픽 텍스처를 줄이는 건 아무 효과가 없습니다.

---
**참고 자료:** [Unreal Summit 2020 - 사례로 배우는 성능 최적화와 프로파일링](https://www.youtube.com/watch?v=hGLIqru5wnI)
